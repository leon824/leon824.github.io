<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="人们常常嘲笑“螳臂当车” 但有时候啊，你并不是驾车的人 正巧是那只，反抗不了的螳螂。">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    单例模式的线程安全问题 |
    
    花谢花开</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="post-单例模式的线程安全问题" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="article-title" itemprop="name">
      单例模式的线程安全问题
    </h1>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/09/07/单例模式的线程安全问题/" class="article-date">
  <time datetime="2018-09-07T07:28:47.000Z" itemprop="datePublished">2018-09-07</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

                    </div>
                    

                        
                            
    <div class="tocbot"></div>





                                

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>  <img src="https://res.cloudinary.com/leon824/image/upload/v1536228571/arches-national-park-dark-dusk-33688_onguan.jpg" width="100%" height="100%"></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是最简单的设计模式，分为两种：懒汉模式、恶汉模式</p>
<h3 id="恶汉模式"><a href="#恶汉模式" class="headerlink" title="恶汉模式"></a>恶汉模式</h3><p>在属性中直接创建对象，然后在方法中返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singletom</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singletom ourInstance = <span class="keyword">new</span> Singletom();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singletom <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ourInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singletom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面不存在线程安全的问题，因为加载类的时候就会创建<code>Singletom</code>的对象，然后所有线程来获取的时候都是返回这个对象。</p>
<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>刚开始并不直接创建对象，而是在需要的时候在创建，主要代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OtherSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OtherSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OtherSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;      ————<span class="number">1</span></span><br><span class="line">                 instance = <span class="keyword">new</span> OtherSingleton(); —————<span class="number">2</span></span><br><span class="line">                 <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候是线程不安全的，假设两个线程一前一后来执行<code>getInstance()</code>方法，这个时候线程<strong>A</strong>正在执行2这个位置，由于<code>new</code>对象并非一个<strong>原子操作</strong>，分为以下<strong>三步</strong>：</p>
<ul>
<li>1) 在内存中分配空间。</li>
<li>2) 调用构造函数初始化对象。</li>
<li>3）将<code>instance</code>引用指向堆内存空间的起始地址（此时<code>instance</code>才为非<code>null</code>）。</li>
</ul>
<p>若将上边三步用伪代码来表示就是下边这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();  <span class="comment">//  1、分配对象的内存空间</span></span><br><span class="line">ctorInstance(memory); <span class="comment">// 2、初始化对象</span></span><br><span class="line">instance = memory；  <span class="comment">//3、设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure>
<p>实际上在上边的伪代码中2和3之间，可能会被重排序（在一些JIT编译器上，这种重排序也是真实发生的） ，根据《java语言规范》，所有线程在执行java程序时必须遵守<strong>intra-thread semantics</strong>,<strong>intra-thread semantics</strong>保证排序不会改变单线程的执行结果。换句话说，<strong>intra-thread semantics</strong>允许那些在单线程中不改变执行结果的重排序，这样会提高程序的执行性能。</p>
<p>这个时候<strong>A</strong>线程执行刚刚才执行到创建对象的<strong>第二步</strong>，线程<strong>B</strong>就执行到代码<strong>1</strong>处，此时判断出<code>instance</code>为<code>null</code>，然后进入对象在创建一个对象！ 这个时候就出现问题了，单例模式此时创建了两个对象。违背了单例模式的初衷。</p>
<h3 id="双重锁检查"><a href="#双重锁检查" class="headerlink" title="双重锁检查"></a>双重锁检查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OtherSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OtherSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OtherSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;  ————<span class="number">1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (OtherSingleton.class)&#123;</span><br><span class="line">             <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;    ————<span class="number">2</span></span><br><span class="line">                 instance = <span class="keyword">new</span> OtherSingleton();   ————<span class="number">3</span></span><br><span class="line">                 <span class="keyword">return</span> instance;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里加双重检查锁就是在同步代码前和同步代码后边都检查实例是否为空。如果仅仅在同步块外边检查，而在同步块内不检查，那么可能存在多个线程同时进入了同步块外的代码，则可能<strong>生成多个实例</strong>。</p>
<p>上边代码看起来还不错，但是他还是有问题的。问题出现在代码<strong>3</strong>处，这个地方并非是原子操作，如上边的描述分为<strong>三步</strong>。由于<code>cpu</code>为了提高执行效率可能会将这个三步分为<strong>1-2-3</strong>或者<strong>1-3-2</strong>。</p>
<p>如果线程<strong>A</strong>执行到代码<strong>3</strong>处的<strong>1-3</strong>步，此时<code>instance</code>已经不为<code>null</code>了，但是创建对象的第二部却并没有执行。而此时线程<strong>B</strong>进入到方法的<strong>1</strong>处，判断<code>instance</code>是否为空，此时已经不会空了，但是返回的对象却并没有初始化，顺理成章的报错。。</p>
<p>这里的关键是<code>instance</code>对象还没有初始化执行<strong>第二步</strong>，就执行的<strong>第三步</strong>，导致线程<strong>B</strong>拿到一个空的对象。那么我们只需要让<code>cpu</code>在执行创建对象时禁止重排序就能够解决这个问题了。<br>明显需要使用<code>volatile</code>关键字来禁止重排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> OtherSingleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OtherSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OtherSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OtherSingleton.class)&#123;</span><br><span class="line">             <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                 instance = <span class="keyword">new</span> OtherSingleton();</span><br><span class="line">                 <span class="keyword">return</span> instance;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里利用的是<code>volatile</code>的禁止重排序的性质，在<code>volatile</code>变量的赋值操作后边会加上一个内存屏障，<strong>读操作</strong>不会出现在内存屏障前边，所以<strong>取操作*必须是</strong>1-2-3<strong>或者</strong>1-3-2<strong>之后，不存在</strong>1-3**之后就读取到。从<code>happen-before</code>原则来看，就是对于一个 <code>volatile</code> 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="noopener">如何正确地写出单例模式</a></li>
<li>《java并发编程的艺术》</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://yoursite.com/2018/09/07/单例模式的线程安全问题/" data-id="ckbyfke0i0008zbyn8x6kpl5g" class="article-share-link">
                                            Share
                                        </a>
                                        
                                    </footer>

    </div>

    
        
  <nav class="article-nav">
    
      <a href="/2019/02/18/历史的逻辑/" class="article-nav-link">
        <strong class="article-nav-caption">Newer</strong>
        <div class="article-nav-title">
          
            历史的逻辑
          
        </div>
      </a>
    
    
      <a href="/2018/09/06/分布式调度中心/" class="article-nav-link">
        <strong class="article-nav-caption">Older</strong>
        <div class="article-nav-title">分布式调度中心</div>
      </a>
    
  </nav>


            

                
                    
                        
                            

</article>
</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 花谢花开</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="花谢花开"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

</body>
</html>